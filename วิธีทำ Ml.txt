######################################################
		ไลบารี่น่ารู้
######################################################
1.) Scikit-Learn
Scikit-Learn เป็นแพ็คเกจที่รวบรวม library ด้าน 
Machine Learning เอาไว้ และถูกออกแบบมาให้ทำงานร่วมกับ 
library ของภาษาโปรแกรมมิง Python อย่าง Numpy และ Scipy ได้ดี 
สามารถสร้างอัลกอริทึมเพื่อให้เรียนรู้ข้อมูล และศึกษาข้อมูลเพิ่มเติมต่อได้

2.)Matplotlib
เป็นโมดูลหนึ่งของ Python เหมาะสำหรับการ Visualize Data 
หรือก็คือการพล็อตข้อมูลออกมาเป็นรูป กราฟ ชาร์ตต่างๆ และเมื่อใช้ร่วมกับ 
Jupytor Notebook ซึ่งผู้ใช้งานสามารถโต้ตอบกับกราฟได้

3.)Pandas
Pandas ย่อมาจาก “Panel Data” 
เป็นแพ็คเกจไลบรารีที่สร้างต่อยอดมาจาก Numpy 
เหมาะกับการทำงานด้วยชุดข้อมูลใหญ่ ซึ่งอาจมีข้อมูลที่ถูก label 
ผิดปะปนเข้ามามาก จะช่วยลดความเสี่ยงที่เกิดจากการเรียงข้อมูลผิดได้ 
แถมยังถูกดีไซน์ให้เหมาะกับการจัดการ รวบรวม และจำลองภาพข้อมูลอีกด้วย

4.) Seaborn
Seaborn เป็นไลบรารีสำหรับสร้างกราฟิกทางสถิติในภาษา Python 
ถูกสร้างขึ้นบน Matplotlib และรวมเข้ากับโครงสร้างข้อมูลของ Pandas 
เป็นเครื่องมือที่แตกต่างจาก Matplotlib ตรงที่มีความเชี่ยวชาญในการแสดงภาพสถิติ 
ใช้ไวยากรณ์น้อยกว่า และมีธีมเริ่มต้นที่เข้าใจง่าย
------------------------------------------------------
AI คืออะไร ? คอมเลียนแบบมนุษย์ 
ML คือ การสอนให้เครื่องเรียนรู้ได้
DL คือ สอนคอมเรียนรู้เลียนแบบโครงสร้างประสาทของมนุษย์

------------------------------------------------------

Datasets คือ ชุดข้อมูลที่เอาไว้สอนML โดยมีลักษณะ
เหมือนกันจัดเป็นชุด เช่น Iris datasets(ดอกไม้) 
MNIST dataset(เลขอารบิก)

------------------------------------------------------
MNIST dataset(image) คือ ชุดข้อมูลลาบมือตัวเลขอารบิกขนาด28x28px 
มีข้อมูลชุดเรียนรู้ 60,000 รูป ชุดทดสอบ 10,000 รูป

 *ข้อมูลชุดเรียนรู้ (training set) เอาไปเทรนMLเพื่อสร้าง
Model

*ข้อมูลชุดทดสอบ (test set) ใช้ทดสอบโมเดลที่สร้างขึ้น
-----------------------------------------------------
#การแสดงภาพด้วย Pylab และ Matplotlib 

import matplotlib.pyplot as plt
from sklearn import datasets
digit_dataset=datasets.load_digits() #ไลบารี่MNIST
print(digit_dataset.target[2])
plt.imshow(digit_dataset.images[2],cmap=plt.get_cmap("gray"))
plt.show()
------------------------------------------------------
การอ่านไฟล์ .mat 
from scipy.io import loadmat

mnist_raw=loadmat("mnist-original.mat")
print(mnist_raw) แสดงรายละเอียดทุกอย่างของรูป(ข้อมูลดิบ)
------------------------------------------------------
การแสดง px ของรูปภาพทั้งหมด
from scipy.io import loadmat
import matplotlib.pyplot as plt#แสดงรูปภพใน dataset

mnist_raw=loadmat("mnist-original.mat")



#create new dict for data and targets
mnist={

    "data":mnist_raw["data"],
	#"data":mnist_raw["data"].T คือการ transpose
    "target":mnist_raw["label"][0],

}

number=x[1500] #กำหนดรูปภาพที่เราสนใจ
number_image=number.reshape(28,28)#แปลงเป็นarray2มิติ
เพื่อนำมาใช้งานในอนาคต
ใช้ plt ในการแสดงผลรูปภาพ

plt.imshow(
    number_image, 
    cmap=plt.cm.binary,
    interpolation="nearest"
    )
plt.show()

print(mnist["data"])
#print(mnist["data"].shape) แสดงtuple(ขนาดของรูป, จ.น.รูป)
------------------------------------------------------
การเขียนโปรแกรมแบบแบ่งชุดข้อมูล

โดยเราควรแบ่งข้อมูลออกเป็น traning 75%, testing 25%
ต้องมีการเก็บค่า 4 ค่า คือ
	-x_train
	-y_train
	-x_test
	-y_test 

คำสั่ง train_test_split() เป็นคำสั่งในการแบ่ง(หั่น)ข้อมูล

from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split

iris_dataset =load_iris()

x_train, x_test, y_train, y_test = 
train_test_split(iris_dataset["data"],iris_dataset["target"], test_size=0.2,random_state=0)

#default 75% 25%
#x_train, x_test เก็บข้อมูลใน iris_dataset["data"]
#y_train, y_test เก็บข้อมูลใน iris_dataset["target"] 
*ตัวเลขสายพันธุ์ดอกไม้
#test_size = ค่าคงที่(0.2, 0.3, 0.5) กำหนดขนาด test_size

print(x_train.shape)
print(x_test.shape)
print(y_train.shape)
print(y_test.shape)
------------------------------------------------------

import seaborn as sb
import matplotlib.pyplot as plt
#Calling the iris datasets to use
iris_dataset=sb.load_dataset("iris")

#set the chart
sb.set() 
#use the pairplot to show
#set hue to "species" to classify the data we have
#the seaborn libary will make data diffrent as species difference
sb.pairplot(iris_dataset,hue="species",size=2)
#show the graph
plt.show()
#print(iris_dataset.head())
#show first 5 table of iris datasets
------------------------------------------------------
Linear regression

y=ax+b เป็น  สมการหลัก

การสร้างกราฟเส้นตรงแบบไม่มีการแสดงผลเรื่องการกระจายตัวกันของข้อมูล
import numpy as np
import matplotlib.pyplot as plt

#--create array 1 dim--#
#creat 10 sub-ranges within range(-5,5) 
x=np.linspace(-5,5,100)
#--set initial equation--#
y=2*x+1 

#--plot the graph--#
#"-r" set red line to the graph
plt.plot(x,y,"-r",label="2x+1")
#--set label to x-axis and y-axis--#
plt.xlabel("x")
plt.ylabel("y")
#--show lebel at the location we want--#
plt.legend(loc="upper left")
#--Show graph name--#
plt.title("Grap 2x+1")
#--represent with the grid--#
plt.grid()
plt.show()
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

การสร้างกราฟแบบมีการกระจายกันของข้อมูล(Scatter)

import numpy as np
import matplotlib.pyplot as plt

#--create array 1 dim--#
#creat 10 sub-ranges within range(-5,5) 
x=np.linspace(-5,5,10)
#--set initial equation--#
y=2*x+1 

#--plot the (Scatter)graph--#
#change plt.plot() to plt.scatter()
#then use this form plt.scatter(x,y)  
plt.scatter(x,y)
#--set label to x-axis and y-axis--#
plt.xlabel("x")
plt.ylabel("y")

"""--!!! No legend to show !!!--"""

#--Show graph name--#
plt.title("Grap 2x+1")
#--represent with the grid--#
plt.grid()
plt.show()
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 การสร้างกราฟแบบมีการกระจายข้อมูลอย่างสุ่ม (เป็นการจำลองชุดข้อมูลขึ้นมา )

import numpy as np
import matplotlib.pyplot as plt

#random numbers in the range we want
rng = np.random
#random the X value in the range we want
x=rng.rand(50)*10
#random the Y value in the range we want
y=2*x+rng.randn(50)

#plot the graph 
plt.scatter(x,y)
plt.xlabel("x")
plt.ylabel("y")
plt.show()
-------------------------------------------------------------------
การสร้างโมเดล Linear Regression

import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression

#--การสร้างแบบจำลองข้อมูล--#
#สุ่มตัวเลข
rng = np.random
#สุ่มค่า x เพื่อจำลองความหลากหลายของข้อมูล
x=rng.rand(50)*10
#สุ่มค่า y เพื่อจำลองความหลากหลายของข้อมูล
y=2*x+rng.randn(50)

#--linear regression model--#
#สร้างแบบจำลองจาก linear regression 
model=LinearRegression()
x_new = x.reshape(-1,1) #เปลี่ยน x เป็น array 2 มิติ 

#--trian algorithm--#
model.fit(x_new,y)

#หาค่า R-Square 0-100% ใช้วัดค่าตัวแปร y ว่าได้กี่% เพื่อเอา y ไปใช้งานต่อ
print(model.score(x_new, y))
"""#หาค่า intercept 
print(model.intercept_)
#หาค่า Coefficient 
print(model.coef_)"""

#--test model--#
xfit=np.linspace(-1,1)
xfit_new=xfit.reshape(-1,1)
yfit_new=model.predict(xfit_new) #

#--analyze model--#
plt.scatter(x,y)
plt.plot(xfit_new,yfit_new)
plt.xlabel("x")
plt.ylabel("y")
plt.show()
------------------------------------------------------------------
การสร้างโมเดลทำนายอุณหภูมิ


import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from pandas.core.frame import DataFrame
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression 

#read file from the folder
"""เมื่อไฟล์อยู่โฟลเดอร์เดียวกับโปรแกรมที่เราใช้งาน"""
datasets1=pd.read_csv("weather.csv")

#read file from the links
datasets2=pd.read_csv("https://raw.githubusercontent.com/kongruksiamza/MachineLearning/master/Linear%20Regression/Weather.csv")

#show all column name(index) in the file
#print(datasets2.keys())

#show min-max temp a day(ordered pair)
#datasets2.plot(x="MinTemp",y="MaxTemp",style="o")
""" การใช้ datasets2 เป็น plot เพราะว่าเราจะได้
ใช้ข้อมูลจากตาราง csv ที่เรามีได้   
แสดงค่าคู่อันดับของอุณหภูมิในแต่ละวัน โดยกำหนดให้
x เป็นค่าของอุณหภูมิต่ำสุด(กำหนดค่าตามชื่อหลัก)
ํํy เป็นค่าของอุณหภูมิสูงสุด(กำหนดค่าตามชื่อหลัก)
ค่าตั้งต้นเป็นกราฟ ถ้าอยากให้เป็นจุด ต้องใช้คำสั่ง
style = '0' """

# plt.title("Min and Max Temp")
# plt.xlabel("Mintemp")
# plt.ylabel("Maxtemp")
# plt.show()

"""การดูข้อมูลเชิงสถิติของแต่ละคอลัมน์"""
# print(datasets2.describe())

# set value to variabl x and y
x = datasets2["MinTemp"].values.reshape(-1,1)
y = datasets2["MaxTemp"].values.reshape(-1,1) 

# train and test set (80% - 20%)
xtrain, xtest, ytrain, ytest = train_test_split(x,y,test_size=0.2,random_state=0)

#training model
model=LinearRegression()
model.fit(xtrain,ytrain)

#testing model
y_predicted=model.predict(xtest)

#To compare real data and predicted data 
df=pd.DataFrame({"Actual value":ytest.flatten(), "Predicted value":y_predicted.flatten()})
"""ใช้คำสั่ง .flatten() ในการแปลง array 2 มิติ
ให้เป็น 1 มิติ """

df1=df.head(20)
"""ดึงข้อมูลของ 20 แถวแรกระหว่าง ค่าจริง และ ค่าทำนาย"""
df1.plot(kind="bar",figsize=(10,5))
"""แสดงข้อมูลเป็นแผนภูมิแท่งผ่านคำสั่ง *kind='bar'* 
   และกำหนดขนาดของหน้าต่างแสดงผลผ่านคำสั่ง *figsize=(10,5)*
"""
plt.show()

------------------------------------------------------------------
ค่าความสัมพันธ์
Coefficient ค่าสัมประสิทธิ์แสดงการตัดสินใจ คือ ตัวเลขที่บอกความสัมพันธ์ของสองตัวแปร หรือ 
ค่าที่แสดงว่าตัวแปร x มีอิทธิพลต่อตัวแปร y มากน้อยเพียงใดโดยมี ขอบเขตในช่วง -1 ถึง 1

Intercept คือ ค่าที่บ่งบอกจุดตัดแกน

R-Square คือ ค่าความผันแปรของตัวแปร y มีค่าอยู่ระหว่าง 0% — 100%
– 0% หมายถึง ผลลัพธ์ที่ได้มานั้นไม่สามารถอธิบายความผันแปรของค่าตัวแปร y ต่างที่กระจายรอบค่าเฉลี่ยได้เลย
– 100% แสดงให้เห็นว่าผลลัพธ์ที่ได้มานั้นสามารถอธิบายความผันแปรของค่าตัวแปร y 
ต่างที่กระจายรอบค่าเฉลี่ยได้เป็นอย่างดี

การวัดประสิทธิภาพ
y_pred คือผลการทำนายผลลัพธ์จากโมเดล
y_test คือ ข้อมูลจริงที่ใช้ทดสอบการทำนายผลโมเดล
Loss Function คือ การคำนวน Error ว่า y_pred ที่โมเดลทำนายออกมา ต่างจาก y_test อยู่เท่าไร 
แล้วหาค่าเฉลี่ย เพื่อที่จะนำมาหา Gradient ของ Loss แล้วใช้อัลกอริทึม Gradient Descent 
เพื่อให้ Loss น้อยลงในการเทรนรอบถัดไป(Loss ยิ่งค่าน้อยยิ่งดี)
Loss Function ที่นิยมใช้ในงาน Regression ในปัจจุบัน มีหลายตัว เช่น Mean Absolute Error 
(MAE) หรือ L1 Loss , Mean Squared Error (MSE) หรือ L2 Loss , 
Root Mean Squared Error (RMSE)

1. Mean Absolute Error (MAE) การคำนวน Error ว่า y_pred ต่างจาก y_test อยู่เท่าไร 
ด้วยการนำมาลบกันตรง ๆ แล้วหาค่าเฉลี่ย โดยไม่สนใจเครื่องหมาย (Absolute) เพื่อหาขนาดของ Error 
โดยไม่สนใจทิศทาง

2. Mean Squared Error (MSE) การคำนวน Error ว่า y_pred ต่างจาก y_test 
อยู่เท่าไร ด้วยการนำมาลบกัน แล้วยกกำลังสอง (Squared) เพื่อไม่ต้องสนใจค่าติดลบ (ถ้ามี) แล้วหาค่าเฉลี่ย

3. Root Mean Squared Error (RMSE) คือ นำ MSE มาหา Squared Root

ค่า MSE, MAE อยู่ในช่วง 0 — Infinity เหมือนกัน ยิ่งน้อยคือยิ่งดีถ้าเป็น 0 คือ ไม่ มีError เลย 
ดังนั้นถ้าค่าเท่ากับ 0 แปลว่าโมเดลทำนายค่า y_test ได้ถูกต้อง100% แต่ในทางปฏิบัติโอกาสที่จะเทรนโมเดลได้ 
loss = 0 เป็นไปได้ยากมาก
อาศัยส่วนของ scikit-learn เข้ามาทำงานร่วมด้วยเพื่อวัดผลจากค่าที่คาดการหรือพยากรณ์ได้จากการ 
predict ตัวโมเดล (y_pred) และค่าจริงจาก y_test
------------------------------------------------------------------
การวัดประสิทธิภาพแบบจำลอง

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from pandas.core.frame import DataFrame
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn import metrics  

#read file from the folder
"""เมื่อไฟล์อยู่โฟลเดอร์เดียวกับโปรแกรมที่เราใช้งาน"""
datasets1=pd.read_csv("weather.csv")

#read file from the links
datasets2=pd.read_csv("https://raw.githubusercontent.com/kongruksiamza/MachineLearning/master/Linear%20Regression/Weather.csv")

#show all column name(index) in the file
#print(datasets2.keys())

#show min-max temp a day(ordered pair)
#datasets2.plot(x="MinTemp",y="MaxTemp",style="o")
""" การใช้ datasets2 เป็น plot เพราะว่าเราจะได้
ใช้ข้อมูลจากตาราง csv ที่เรามีได้   
แสดงค่าคู่อันดับของอุณหภูมิในแต่ละวัน โดยกำหนดให้
x เป็นค่าของอุณหภูมิต่ำสุด(กำหนดค่าตามชื่อหลัก)
ํํy เป็นค่าของอุณหภูมิสูงสุด(กำหนดค่าตามชื่อหลัก)
ค่าตั้งต้นเป็นกราฟ ถ้าอยากให้เป็นจุด ต้องใช้คำสั่ง
style = '0' """

# plt.title("Min and Max Temp")
# plt.xlabel("Mintemp")
# plt.ylabel("Maxtemp")
# plt.show()

"""การดูข้อมูลเชิงสถิติของแต่ละคอลัมน์"""
# print(datasets2.describe())

# set value to variabl x and y
x = datasets2["MinTemp"].values.reshape(-1,1)
y = datasets2["MaxTemp"].values.reshape(-1,1) 

# train and test set (80% - 20%)
xtrain, xtest, ytrain, ytest = train_test_split(x,y,test_size=0.2,random_state=0)

#training model
model=LinearRegression()
model.fit(xtrain,ytrain)

#testing model
y_predicted=model.predict(xtest)

#To compare real data and predicted data 
df=pd.DataFrame({"Actual value":ytest.flatten(), "Predicted value":y_predicted.flatten()})
"""ใช้คำสั่ง .flatten() ในการแปลง array 2 มิติ
ให้เป็น 1 มิติ """

df1=df.head(20)
"""ดึงข้อมูลของ 20 แถวแรกระหว่าง ค่าจริง และ ค่าทำนาย"""
df1.plot(kind="bar",figsize=(10,5))
"""แสดงข้อมูลเป็นแผนภูมิแท่งผ่านคำสั่ง *kind='bar'* 
   และกำหนดขนาดของหน้าต่างแสดงผลผ่านคำสั่ง *figsize=(10,5)*
"""
#plt.show()

print("MAE :", metrics.mean_absolute_error(ytest,y_predicted))
print("MSE :", metrics.mean_squared_error(ytest,y_predicted))
print("RMAE :", np.sqrt(metrics.mean_squared_error(ytest,y_predicted)))
print("Score :",metrics.r2_score(ytest,y_predicted)*100,"%")

-------------------------------------------------------------------

Binary Classifier

ตัวจำแนกแบบไบนารี (Binary Classifier) เป็นวิธีการแบ่งข้อมูลออกเป็น 2 กลุ่ม (Binary Class) 
จากภาพตัวอย่างจะแบ่งข้อมูลออกเป็น 2 กลุ่ม คือ กลุ่มสีแดงและกลุ่มสีน้ำเงิน (Class สีแดง และ Class สีน้ำเงิน)
โดยใช้เส้น Hyperplane (เส้นสมมุติ | เส้น Linear Regression) แบ่งกลุ่มข้อมูลทั้ง 2 กลุ่มแยกออกจากกัน

ภายใน LAB จะยกตัวอย่างเพื่อให้เห็นการแบ่งกลุ่มของข้อมูลโดยใช้ MNIST Dataset 
ว่าข้อมูลกลุ่มใดแสดงกลุ่มตัวเลข 0–9 โดยข้อมูลทั้งหมดจะมี 70,000 ชุดจะต้องเขียนโปรแกรมแบ่งข้อมูลออกเป็น 2 ส่วนได้แก่
- Training Set 60,000 ชุด
- Test Set 10,000 ชุด

from scipy.io import loadmat
import numpy as np
import matplotlib.pyplot as plt
mnist_raw = loadmat("mnist-original.mat")
mnist = {
   "data":mnist_raw["data"].T,
   "target":mnist_raw["label"][0]
}

x,y = mnist["data"],mnist["target"]

xtrain,xtest,ytrain,ytest = x[:60000], x[60000:], y[:60000],y[60000:] 

print(xtrain.shape)
print("########################")
print(xtest.shape)
print("########################")
print(ytrain.shape)
print("########################")
print(ytest.shape)


//////////////////////////////////////////////////////////////////

from scipy.io import loadmat
import numpy as np
import matplotlib.pyplot as plt
mnist_raw = loadmat("mnist-original.mat")
mnist = {
   "data":mnist_raw["data"].T,
   "target":mnist_raw["label"][0]
}

x,y = mnist["data"],mnist["target"]

xtrain,xtest,ytrain,ytest = x[:60000], x[60000:], y[:60000],y[60000:] 

#class 0, class not 0
#ข้อมูล 1 ค่า -> data model ->class 0 ? true: false 
predict = 500
#create boolean array if the value equals zero
ytrain_0 = (ytrain==0)
ytest_0 = (ytest==0)

print(ytest_0.shape, ytrain_0)
print("########################")
print(ytrain_0.shape, ytrain_0)

-------------------------------------------------------------------

Stochastic Gradient Descent(SGD) 



from scipy.io import loadmat
from sklearn.linear_model import SGDClassifier
import numpy as np
import matplotlib.pyplot as plt

def displayImage(x):
    plt.imshow(
        x.reshape(28,28),
        cmap=plt.cm.binary,
        interpolation="nearest")
    plt.show()

def displayPredict(clf, actually_y,x_test):
    print("Actually:",actually_y)
    print("Prediction:",clf.predict([x_test][0]))   
 
mnist_raw = loadmat("mnist-original.mat")
mnist = {
   "data":mnist_raw["data"].T,
   "target":mnist_raw["label"][0]
}

x,y = mnist["data"],mnist["target"]

xtrain,xtest,ytrain,ytest = x[:60000], x[60000:], y[:60000],y[60000:] 

#class 0, class not 0
#ข้อมูล 1 ค่า -> data model ->class 0 ? true: false 
predict_number = 5000
#create boolean array if the value equals zero
ytrain_0 = (ytrain==0)
ytest_0 = (ytest==0)


sgd_clf = SGDClassifier() 
"""สร้าง Object SGD แยกกลุ่มของข้อมมูลที่เป็นเลข 0 กับไม่ใช่ แยกกัน"""
sgd_clf.fit(xtrain,ytrain_0)
"""เทรนข้อมูลทั้งหมดโดยเช็ค class""" 

displayImage(xtest[predict_number])
displayPredict(sgd_clf,ytest_0,xtest[predict_number])

-------------------------------------------------------------------

Cross Validation

Cross-validation Test การทดสอบประสิทธิภาพของโมเดลด้วยวิธี Cross-validation 
นี้จะทําการแบ่งข้อมูลออกเป็นหลายๆส่วน (k) เช่นกำหนดให้ k-fold=3 แสดงว่ามีการแบ่งข้อมูลออกเป็น 3 ส่วน 
หรือการทดลอง 3 ครั้งโดยผลลัพธ์ที่ได้จะบอก ผลการทดลองครั้งที่ 1 , 2 และ 3 ตามลำดับ

from scipy.io import loadmat
from sklearn.linear_model import SGDClassifier
from sklearn.model_selection import cross_val_score
import numpy as np
import matplotlib.pyplot as plt

def displayImage(x):
    plt.imshow(
        x.reshape(28,28),
        cmap=plt.cm.binary,
        interpolation="nearest")
    plt.show()

def displayPredict(clf, actually_y,x_test):
    print("Actually:",actually_y)
    print("Prediction:",clf.predict([x_test][0]))   
 
mnist_raw = loadmat("mnist-original.mat")
mnist = {
   "data":mnist_raw["data"].T,
	"""เก็บข้อมูล ตัวเลข และ ขนาดของรูป"""
   "target":mnist_raw["label"][0]
	"""เก็บข้อมูลตัวเลข 0-9 บอกกลุ่มของตัวเลข"""
}

x,y = mnist["data"],mnist["target"]

xtrain,xtest,ytrain,ytest = x[:60000], x[60000:], y[:60000],y[60000:] 

#class 0, class not 0
#ข้อมูล 1 ค่า -> data model ->class 0 ? true: false 
predict_number = 5000
#create boolean array if the value equals zero
ytrain_5 = (ytrain==5)
ytest_5 = (ytest==5)


sgd_clf = SGDClassifier() 
"""สร้าง Object SGD"""
sgd_clf.fit(xtrain,ytrain_5)
"""เทรนข้อมูลทั้งหมดโดยเช็ค class""" 

score = cross_val_score(sgd_clf,xtrain,ytrain_5,cv=3,scoring="accuracy")
print(score)

---------------------------------------------------------------

Confusion Matrix
	
	ใช้วัดประสิทธิภาพของตัวโมเดล

from scipy.io import loadmat
from sklearn.linear_model import SGDClassifier
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import cross_val_predict
from sklearn.metrics import confusion_matrix
import itertools 
import numpy as np
import matplotlib.pyplot as plt

def displayConfusionMatrix(cm,cmap=plt.cm.Spectral):
    classes_x=["Other Number","Number 5"]
    classes_y=["Other Number Group","Number 5 Group"]
    plt.imshow(cm,interpolation='nearest',cmap=cmap)
    plt.title("Confusion Matrix")
    plt.colorbar()
    trick_marks=np.arange(len(classes_x))
    plt.xticks(trick_marks,classes_x)
    plt.yticks(trick_marks,classes_y)
    thresh=cm.max()/2
    for i , j in itertools.product(range(cm.shape[0]),range(cm.shape[1])):
        plt.text(j,i,format(cm[i,j],'d'),
        horizontalalignment='center',
        color='white' if cm[i,j]>thresh else 'black')

    plt.tight_layout()
    plt.ylabel('Actually')
    plt.xlabel('Prediction')
    plt.show()

def displayImage(x):
    plt.imshow(
        x.reshape(28,28),
        cmap=plt.cm.binary,
        interpolation="nearest")
    plt.show()

def displayPredict(clf, actually_y,x_test):
    print("Actually:",actually_y)
    print("Prediction:",clf.predict([x_test])[0])   
 
mnist_raw = loadmat("mnist-original.mat")
mnist = {
   "data":mnist_raw["data"].T,
   "target":mnist_raw["label"][0]
}

x,y = mnist["data"],mnist["target"]

xtrain,xtest,ytrain,ytest = x[:60000], x[60000:], y[:60000],y[60000:] 

#class 0, class not 0
#ข้อมูล 1 ค่า -> data model ->class 0 ? true: false 
predict_number = 6000
#create boolean array if the value equals zero
ytrain_5 = (ytrain==5)
ytest_5 = (ytest==5)

sgd_clf = SGDClassifier() 
"""สร้าง Object SGD"""
sgd_clf.fit(xtrain,ytrain_5)
"""เทรนข้อมูลทั้งหมดโดยเช็ค class""" 

ytrain_pred = cross_val_predict(sgd_clf,xtrain,ytrain_5,cv=3)
cm=confusion_matrix(ytrain_5,ytrain_pred)

print(cm)

plt.figure()
displayConfusionMatrix(cm,)
---------------------------------------------------------------

ค่า Precision, Recall, F1-Score

True Positive (TP) — ทายว่าถูกต้อง แล้วตอบตรงตามที่ทายไว้
True Negative (TN) — ทายว่าไม่ถูกต้อง แล้วตอบตรงตามที่ทายไว้
False Positive (FP) — ทายว่าถูกต้อง แต่คำตอบคือไม่ถูกต้อง
False Negative (FN)- ทายว่าไม่ถูกต้อง แต่คำตอบคือถูกต้อง

Precision = TP/(TP+FP)

Recall = TP/(TP+FN)

Accuracy = (TP+TN)/total

from scipy.io import loadmat
from sklearn.linear_model import SGDClassifier
from sklearn.model_selection import cross_val_predict
from sklearn.metrics import confusion_matrix,classification_report
import itertools 
import numpy as np
import matplotlib.pyplot as plt

def displayConfusionMatrix(cm,cmap=plt.cm.Spectral):
    classes_x=["Other Number","Number 5"]
    classes_y=["Other Number Group","Number 5 Group"]
    plt.imshow(cm,interpolation='nearest',cmap=cmap)
    plt.title("Confusion Matrix")
    plt.colorbar()
    trick_marks=np.arange(len(classes_x))
    plt.xticks(trick_marks,classes_x)
    plt.yticks(trick_marks,classes_y)
    thresh=cm.max()/2
    for i , j in itertools.product(range(cm.shape[0]),range(cm.shape[1])):
        plt.text(j,i,format(cm[i,j],'d'),
        horizontalalignment='center',
        color='white' if cm[i,j]>thresh else 'black')

    plt.tight_layout()
    plt.ylabel('Actually')
    plt.xlabel('Prediction')
    plt.show()

def displayImage(x):
    plt.imshow(
        x.reshape(28,28),
        cmap=plt.cm.binary,
        interpolation="nearest")
    plt.show()

def displayPredict(clf, actually_y,x_test):
    print("Actually:",actually_y)
    print("Prediction:",clf.predict([x_test])[0])   
 
mnist_raw = loadmat("mnist-original.mat")
mnist = {
   "data":mnist_raw["data"].T,
   "target":mnist_raw["label"][0]
}

x,y = mnist["data"],mnist["target"]

xtrain,xtest,ytrain,ytest = x[:60000], x[60000:], y[:60000],y[60000:] 

#class 0, class not 0
#ข้อมูล 1 ค่า -> data model ->class 0 ? true: false 
predict_number = 6000
#create boolean array if the value equals zero
ytrain_5 = (ytrain==5)
ytest_5 = (ytest==5)

sgd_clf = SGDClassifier() 
"""สร้าง Object SGD"""
sgd_clf.fit(xtrain,ytrain_5)
"""เทรนข้อมูลทั้งหมดโดยเช็ค class""" 

ytrain_pred = cross_val_predict(sgd_clf,xtrain,ytrain_5,cv=3)
cm=confusion_matrix(ytrain_5,ytrain_pred)

ytest_pred = sgd_clf.predict(xtest)

classes = ["Other numbers","Number 5"]
print(classification_report(ytest_pred,ytest_5,target_names=classes))

---------------------------------------------------------------





